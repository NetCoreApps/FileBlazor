@page "/aws/{AccessType}"
@using FileBlazor.ServiceModel.Types
@using System.IO
@using System.Net.Http.Headers
@using System.Text.Json
@inject ServiceStackStateProvider AuthStateProvider;
@inject NavigationManager NavigationManager;
@inherits AppComponentBase
@inject JsonApiClient jsonApiClient;
<h3>Aws View - @FileAccessType.ToString()</h3>
<div>

    <div class="max-w-xl" @ref="fileDropContainer"
    >
    <label for="blazor-input-file"
        class="flex justify-center w-full h-32 px-4 transition border-2 border-gray-300 border-dashed rounded-md appearance-none cursor-pointer hover:border-gray-400 focus:outline-none">
        <span class="flex items-center space-x-2">
            <svg xmlns="http://www.w3.org/2000/svg" class="w-6 h-6 text-gray-600" fill="none" viewBox="0 0 24 24"
                stroke="currentColor" stroke-width="2">
                <path stroke-linecap="round" stroke-linejoin="round"
                    d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12" />
            </svg>
            @if(!showProgress)
            {
                <span class="font-medium text-gray-600">
                    Drop files to Attach, or <span class="text-blue-600 underline">browse</span>
                </span>
            }
            else
            {
                if(uploading)
                {
                    <span class="font-medium text-gray-600">
                        Uploading file "@selectedFile"...
                    </span>
                }
                else
                {
                    <span class="font-medium text-gray-600">
                        Upload complete!
                    </span>
                }
            }
            
            
        </span>
        @if(toggleInputClear)
            {
                <InputFile id="blazor-input-file" OnChange="@OnChange" class="w-auto absolute opacity-0 h-32" />
            }
            else
            {
                <InputFile id="blazor-input-file" OnChange="@OnChange" class="w-auto absolute opacity-0 h-32" />
            }
    </label>

</div>

    @if(FileAccessType == ServiceModel.Types.FileAccessType.Gallery && AppFiles != null)
    {
        <GalleryItems AppFiles="GalleryAppFiles"></GalleryItems>
    }
    @if(FileAccessType == ServiceModel.Types.FileAccessType.Private && AppFiles != null)
    {
        <GalleryItems AppFiles="PrivateAppFiles"></GalleryItems>
    }
    @if(FileAccessType == ServiceModel.Types.FileAccessType.Public && AppFiles != null)
    {
        <GalleryItems AppFiles="PublicAppFiles"></GalleryItems>
    }

    

</div>

@code {
    [Parameter]
    public string? AccessType { get; set; }

    private FileAccessType? FileAccessType;
    // Hack to clear files, avoids issues upload file with same name.
    bool toggleInputClear = false;

    private List<IAppFile> AppFiles { get; set; } = new List<IAppFile>();

    private List<IAppFile> PrivateAppFiles { get; set; } = new List<IAppFile>();
    private List<IAppFile> PublicAppFiles { get; set; } = new List<IAppFile>();
    private List<IAppFile> GalleryAppFiles { get; set; } = new List<IAppFile>();
    ResponseStatus? errorStatus;

    ElementReference fileDropContainer;

    private bool dragHover = false;

    private bool showProgress = false;
    private bool uploading = false;
    private string selectedFile = "";


    private async Task OnChange(InputFileChangeEventArgs e)
    {
        long maxFileSize = 1024 * 1024 * 15;
        var req = new CreateS3File
            {
                FileAccessType = FileAccessType
            };

        using var content = new MultipartFormDataContent()
            .AddParams(req);

        var file = e.File;
        selectedFile = file.Name;
        uploading = true;
        showProgress = true;

        if(file.Name.IndexOfAny(Path.GetInvalidFileNameChars()) >= 0)
        {
            // show error and return;
            return;
        }
        using var stream = file.OpenReadStream(maxFileSize);
        using var ms = new MemoryStream();
        await stream.CopyToAsync(ms);
        ms.Position = 0;
        content.AddFile(nameof(CreateS3File.AppFile), file.Name, ms, file.ContentType);

        var api = await jsonApiClient.ApiFormAsync<CreateS3File>(typeof(CreateS3File).ToApiUrl(), content);
        uploading = false;
        StateHasChanged();

        await refreshFiles();
        StateHasChanged();
        await updateStatus();
        toggleInputClear = !toggleInputClear;
        StateHasChanged();
    }

    async Task updateStatus()
    {
        await Task.Delay(3000);
        showProgress = false;
    }

    protected override async Task OnInitializedAsync()
    {
        await refreshFiles();
        await base.OnInitializedAsync();
    }

    async Task refreshFiles()
    {
        var api = await ApiAsync(new QueryAppUserS3File());
        if (api.Succeeded)
        {
            GalleryAppFiles.Clear();
            PublicAppFiles.Clear();
            PrivateAppFiles.Clear();
            GalleryAppFiles.AddRange(api.Response!.Results.Where(x => x.FileAccessType == ServiceModel.Types.FileAccessType.Gallery).Select(x => x.AppFile));
            PublicAppFiles.AddRange(api.Response!.Results.Where(x => x.FileAccessType == ServiceModel.Types.FileAccessType.Public).Select(x => x.AppFile));
            PrivateAppFiles.AddRange(api.Response!.Results.Where(x => x.FileAccessType == ServiceModel.Types.FileAccessType.Private).Select(x => x.AppFile));
        }
        else
            errorStatus = api.Error;
    }

    protected override async Task OnParametersSetAsync()
    {
        if(AccessType == null)
            NavigationManager.NavigateTo("/aws");
        else
        {
            FileAccessType = AccessType.ToEnum<FileAccessType>();
        }
        await base.OnParametersSetAsync();
    }
}